(UNNAMED) PROFILING TOOL
------------------------

PURPOSE
-------

To provide raw-data access to instrumentation, while minimizing impact on the
system being observed. 

CONSTRAINTS
-----------
The system being observed has to get into a proper state first.  In the
Torque/Quake examples, this means that I need to get the right number of load
simulators attached & running.  

PROPOSED APPROACH
-----------------
A tool is created.  It takes as input a simple structure declaration,
describing related data elements that will eventually become a single row in
a table.  Using the tool, the system being observed will output copies of
this structure, called 'frames', over shared memory to a reader process.  No
explicit synchronization is done between the two processes, to minimize
interference with the system being observed.  

It generates two artifacts:

(1) A small header & source component to be compiled & linked into the
executable being observed.  This component includes types and functions
to facilitate the filling of the structure, copying it to shared memory, and
for attaching/detaching that shared memory segment.

(2) A reader program that reads the frames off of the same shared memory
segment and essentially fprintf()s them to a text file.

After these two artifacts are generated, the component is integrated into the
system being observed.  The tool is used to enable the instrumentation and
invoke the reading process.

IMPLEMENTATION
--------------
The frame definition is a dead-simple C-style structure declaration:
struct Foo {
       int some_count;
       double some_value;
};

We reorder the elements to minimize padding.  Additionally, a sequence number
is added to prevent the reader process from reading frames twice.

Next, the header & source of the component is generated.  The files include
the altered frame definition, a few global variables (described below), some
macros to fill the frame, and a function to write it to shared memory.

This final function will check two values:
(1) A shared-memory handle
(2) A pointer to the buffer

When the system is not being observed, both values are null.  There are four
states:

| Name          | Handle | Pointer | Function Action                     |
|---------------+--------+---------+-------------------------------------|
| not-observing | null   | null    | ignore the frame                    |
| start-observe | !null  | null    | attach shared memory, start writing |
| observing     | !null  | !null   | keep writing frames to shared mem   |
| end-observe   | null   | !null   | detch shared memory, stop writing   |

The handle is managed externally (we'll get to this in a sec).  The
pointer is managed by the frame-write routine generated by the tool.

When used to begin an observation, the tool creates a shared memory
segment.  It takes the identifier for this segment and (using /proc),
using both symbolic data available in the executable and access to its
address space, modifies the generated global variable to move it
between the null and not-null states.  When the observed process has
the shared memory handle, the reader process is started with the same
handle.  It simply reads the circular buffer until ^C, writing its
output to a file.


