
* API Plans
  - A MOP type?
** Plain C, $(cpp) metaprogramming
  - In plain C,  It'd be a whole lotta macros to do this, but I can
    use C structure semantics for the frame-relative stuff.
  - Can I use the old (re)define-macro, re-include trick?
  - May require I #include <macro-parameter>.  Does that work?
    -It does, but it's about the deep limit of what you can do, and it
    ain't pretty.
  - So define the same macros for different passes:
    (1) Packing optimization - All the counters up front, the doubles
    in the back
    (2) Cache line counting - Take the total size of the frame data,
    break it up into individual lines.  Make sure no store takes more
    than 1 cache-line write.
    - Can this work? Can I do a counting phase, then push the packing
      into each line?  I can use unions with sz=(cache-line-size) to
      ensure I have the right size.
    - I guess this'd also define my frame-save routines as well?

*** Good idea for now?
    - Fuck no, it's too much metaprogramming bs work.  Screw the cache
      line stuff for now, make it basically work, then optimize later.

* Haskell Based
  Yay!
** Reading shared memory  
   Convert the description into a 'Format'.
   Write a Format -> ByteStream -> Get Frame
   

* LLVM Notes
  LLVM has a packed structure type that we can generate decls for from
  frames
  

* IO Notes

** Reader

The problem is that I need a quick while () loop iteration statement
that will stop in the case that the next value is less than the
current.  The problem is on rollover.  Then I'm stuck on the element
with max(seqno).

I can make it behave better by waiting for a full buffer flush, but
that's a waste.  The minimum value should be a /sentinel/.  There
should only ever be one in the buffer at a time.  That's the rule.

Let $b$ be the buffer size.

I keep a counter $c$ for the number of values I saw since the last
sentinel.  If I see one again, I check if $c!=b$, then I keep
reading.  Else, stop there, and stop at the previous (max seqno) elem.


* Tool name: 'pit': portable instrumentation tool
  Modeled after git.
** Nah, name it 'pt'.  "Performance Tool"
  It'll have a .pt directory, with:
  
** Measurements
   .pit/measurements -- All your data, in raw form (.gz'd).
   Use pit export <measurement> --format <fmt> for getting data
   out
   Or pit report <measurement> --format for a quick report.

   Measurements should be able to auto-stamp themselves with
   what they were taken of.  pit could look around for local .svn
   or .git directories ? for auto-stamping the version of the
   executable. It could look for symbols in the executables to
   identify the version.

   That's probably the easiest & most immediately-straight
   forward. 

** Generated Code
   .pit/readers -- Generated code for reading all the frame
   types.  This can include single and multi-threaded code.  How
   to do that?

   pit measure [desc] -p <pid> 
   or
   pit measure [desc] <fname> args

*** A single-proc'd reader
    We want a single thread & process to do all the
    measurement for us.

** Configuration Data
   .pit/config -- What symbol to stamp the measurements with?
   Defaut formats for reports and export?
   Settings for different executables in a project

** Some sort of version policy
   We have to store what version of the software we measured.
   This could be a (filename, last file write date, hash) tuple.
   
* Current (v0.1 - thesis) release
  use .pt, save in .pt/readers.
  Single threaded, single project.

** Platform differences
   - LLVM generally isn't available on solaris.
   - A degenerate loader program (perhaps a platform-specific helper
     app) is needed for Solaris.

   - Making 'pt' work over ssh could be useful in a variety of
     situations
     - Like when I'm simulating on a fracking cluster!!

   - It'll be dead-small.  Just an ELF reader and process-specific
     calls to embed the symbol in.
     - DO IT IN C!! Use libelf.
     - It'll do the insertion and never worry about ghc.
     - GHC can just do the code generation & real computation work
     - So damn portable it doesn't even run native!
     - Later on it can become the local platform agent.
       That's the name. pt-agent -symlink-> pt-solaris-agent
       
   
