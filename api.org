
* API Plans
  - A MOP type?
** Plain C, $(cpp) metaprogramming
  - In plain C,  It'd be a whole lotta macros to do this, but I can
    use C structure semantics for the frame-relative stuff.
  - Can I use the old (re)define-macro, re-include trick?
  - May require I #include <macro-parameter>.  Does that work?
    -It does, but it's about the deep limit of what you can do, and it
    ain't pretty.
  - So define the same macros for different passes:
    (1) Packing optimization - All the counters up front, the doubles
    in the back
    (2) Cache line counting - Take the total size of the frame data,
    break it up into individual lines.  Make sure no store takes more
    than 1 cache-line write.
    - Can this work? Can I do a counting phase, then push the packing
      into each line?  I can use unions with sz=(cache-line-size) to
      ensure I have the right size.
    - I guess this'd also define my frame-save routines as well?

*** Good idea for now?
    - Fuck no, it's too much metaprogramming bs work.  Screw the cache
      line stuff for now, make it basically work, then optimize later.

* Haskell Based
  Yay!
** Reading shared memory  
   Convert the description into a 'Format'.
   Write a Format -> ByteStream -> Get Frame
   

* LLVM Notes
  LLVM has a packed structure type that we can generate decls for from
  frames
  

* IO Notes

** Reader

The problem is that I need a quick while () loop iteration statement
that will stop in the case that the next value is less than the
current.  The problem is on rollover.  Then I'm stuck on the element
with max(seqno).

I can make it behave better by waiting for a full buffer flush, but
that's a waste.  The minimum value should be a /sentinel/.  There
should only ever be one in the buffer at a time.  That's the rule.

Let $b$ be the buffer size.

I keep a counter $c$ for the number of values I saw since the last
sentinel.  If I see one again, I check if $c!=b$, then I keep
reading.  Else, stop there, and stop at the previous (max seqno) elem.


* Tool name: 'pit': portable instrumentation tool
  Modeled after git.
** Nah, name it 'pt'.  "Performance Tool"
  It'll have a .pt directory, with:
  
** Measurements
   .pit/measurements -- All your data, in raw form (.gz'd).
   Use pit export <measurement> --format <fmt> for getting data
   out
   Or pit report <measurement> --format for a quick report.

   Measurements should be able to auto-stamp themselves with
   what they were taken of.  pit could look around for local .svn
   or .git directories ? for auto-stamping the version of the
   executable. It could look for symbols in the executables to
   identify the version.

   That's probably the easiest & most immediately-straight
   forward. 

** Generated Code
   .pit/readers -- Generated code for reading all the frame
   types.  This can include single and multi-threaded code.  How
   to do that?

   pit measure [desc] -p <pid> 
   or
   pit measure [desc] <fname> args

*** A single-proc'd reader
    We want a single thread & process to do all the
    measurement for us.

** Configuration Data
   .pit/config -- What symbol to stamp the measurements with?
   Defaut formats for reports and export?
   Settings for different executables in a project

** Some sort of version policy
   We have to store what version of the software we measured.
   This could be a (filename, last file write date, hash) tuple.
   
=* Current (v0.1 - thesis) release
  use .ppt, save in .ppt/readers.
  Single threaded, single project.

** Platform differences
   - LLVM generally isn't available on solaris for ghc.
   - A degenerate loader program (perhaps a platform-specific helper
     app) is needed for Solaris.

   - Making 'ppt' work over ssh could be useful in a variety of
     situations
     - Like when I'm simulating on a fracking cluster!!

   - It'll be dead-small.  Just an ELF reader and process-specific
     calls to embed the symbol in.
     - DO IT IN C!! Use libelf.
     - It'll do the insertion and never worry about ghc.
     - GHC can just do the code generation & real computation work
     - So damn portable it doesn't even run native!
     - Later on it can become the local platform agent.
       That's the name. ppt-agent -symlink-> ppt-solaris-agent
** Current status, new work
   Using this toolchain:
   function llvm () {
      LD_LIBRARY_PATH=/lib:/usr/lib:/opt/local/lib:/opt/csw/lib "$@"
   }
   llvm opt -O2 beta1.lli >beta1b.lli
   llvm llc beta1b.lli
   gcc -o beta1b beta1b.lli.s
   I can assemble & link the executable.
   
** Generated Code
   Thankfully, the llvm distribution has an examples/ directory, which
   covered VarArgs for me.

   
** Current Status   
*** <2010-12-21 Tue> The generated function
    General structure is in writeup.

    reifying the struct.
    it doesn't use pure tuple types, it uses a nice list-like
    structure with :&!!  I can work with that, I believe.

    The current 'callPuts' needs to take another arg, to a function
    that'll do the actual read & fprintf().  That function will do the
    equivalent of 'defineBasicBlock', reading the type from memory and
    then incrementing the pointer.

    We'll need a wrapper that'll build the getElement


| > -- | Reification function. In CPS style (best possible solution)
| > reifyIntegral :: Integral i => i -> (forall n . Nat n => n -> r) -> r
| > reifyIntegral i f 
| >  | i < 0     = error "reifyIntegral: integral < 0"
| >  | i == 0    = f (undefined :: D0)
| >  | otherwise = reifyIntegralp i f                       return 0
| >        -- reifyIntegral for positives
| >  where reifyIntegralp :: Integral i => i -> (forall n . Pos n => n -> r) -> r
| >        reifyIntegralp i f 
| >          | i < 10 = case i of
| >                      1 -> f (undefined :: D1)
| >                      2 -> f (undefined :: D2); 3 -> f (undefined :: D3)
| >                      4 -> f (undefined :: D4); 5 -> f (undefined :: D5)
| >                      6 -> f (undefined :: D6); 7 -> f (undefined :: D7)
| >                      8 -> f (undefined :: D8); 9 -> f (undefined :: D9)
| >          | otherwise =  
| >             case m of
| >               0 -> reifyIntegralp d (\ (_::e) -> f (undefined :: e :* D0)) 
| >               1 -> reifyIntegralp d (\ (_::e) -> f (undefined :: e :* D1))
| >               2 -> reifyIntegralp d (\ (_::e) -> f (undefined :: e :* D2))
| >               3 -> reifyIntegralp d (\ (_::e) -> f (undefined :: e :* D3))
| >               4 -> reifyIntegralp d (\ (_::e) -> f (undefined :: e :* D4))
| >               5 -> reifyIntegralp d (\ (_::e) -> f (undefined :: e :* D5))
| >               6 -> reifyIntegralp d (\ (_::e) -> f (undefined :: e :* D6))
| >               7 -> reifyIntegralp d (\ (_::e) -> f (undefined :: e :* D7))
| >               8 -> reifyIntegralp d (\ (_::e) -> f (undefined :: e :* D8))
| >               9 -> reifyIntegralp d (\ (_::e) -> f (undefined :: e :* D9))      
| >            where (d,m) = divMod i 10



* <2011-07-20 Wed> Next to do
** DONE Implement the proper layouts & data structures
** DONE Add the discriminator type

* Attach Command
** Versions
   For now, just the latest version against the process, nothing fancy.
   Later, parse the error message out of ppt-agent, and pull the proper
   version of the spec out of the repo.

   Eventually, add a 'tag' property to the spec, so that we can give
   them semantic names (ala git tags).  They could attach to
   release/version-control release identifiers.  A specialized
   'current' value can be used (or, we treat the latest version
   specially) to allow for experimentation.

** Building the listener
   Hmm, perhaps this is a clang-ism? Or I'll just directly invoke
   llvm?

   I'm generating the listener, and I should keep LLVM as a dependency
   that others shouldn't have to worry about.

