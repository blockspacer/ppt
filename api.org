
* API Plans
  - A MOP type?
** Plain C, $(cpp) metaprogramming
  - In plain C,  It'd be a whole lotta macros to do this, but I can
    use C structure semantics for the frame-relative stuff.
  - Can I use the old (re)define-macro, re-include trick?
  - May require I #include <macro-parameter>.  Does that work?
    -It does, but it's about the deep limit of what you can do, and it
    ain't pretty.
  - So define the same macros for different passes:
    (1) Packing optimization - All the counters up front, the doubles
    in the back
    (2) Cache line counting - Take the total size of the frame data,
    break it up into individual lines.  Make sure no store takes more
    than 1 cache-line write.
    - Can this work? Can I do a counting phase, then push the packing
      into each line?  I can use unions with sz=(cache-line-size) to
      ensure I have the right size.
    - I guess this'd also define my frame-save routines as well?

*** Good idea for now?
    - Fuck no, it's too much metaprogramming bs work.  Screw the cache
      line stuff for now, make it basically work, then optimize later.

* Haskell Based
  Yay!
** Reading shared memory  
   Convert the description into a 'Format'.
   Write a Format -> ByteStream -> Get Frame
   

* LLVM Notes
  LLVM has a packed structure type that we can generate decls for from
  frames
  

* IO Notes

** Reader

The problem is that I need a quick while () loop iteration statement
that will stop in the case that the next value is less than the
current.  The problem is on rollover.  Then I'm stuck on the element
with max(seqno).

I can make it behave better by waiting for a full buffer flush, but
that's a waste.  The minimum value should be a /sentinel/.  There
should only ever be one in the buffer at a time.  That's the rule.

Let $b$ be the buffer size.

I keep a counter $c$ for the number of values I saw since the last
sentinel.  If I see one again, I check if $c!=b$, then I keep
reading.  Else, stop there, and stop at the previous (max seqno) elem.

